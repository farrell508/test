<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Modern Clock + Board + Noise Alert</title>
  <link rel="stylesheet" href="main.css">
  <script src="https://cdn.jsdelivr.net/npm/fireworks-js@2.x/dist/index.umd.js"></script>

  <!-- 노이즈 미터와 버튼을 묶어서 오른쪽 위에 세로로 배치 -->

</head>
<body>
  <!-- Magnet Container -->
  <div class="magnet-container" id="magnetContainer"></div>

  <!-- 왼쪽 위: 기타 사유 패널 -->
  <div id="reasonPanel">
    <div class="panel-title">기타 사유</div>
    <div id="reasonList"></div>
  </div>

  <!-- Board Container -->
  <div class="board-container">
    <div class="board-title">상태창</div>
    <div class="board-grid">
      <div class="board-section" data-category="toilet">
        <div class="section-title">화장실(물)</div>
        <div class="section-content" id="toilet-content"></div>
      </div>
      <div class="board-section" data-category="hallway">
        <div class="section-title">복도</div>
        <div class="section-content" id="hallway-content"></div>
      </div>
      <div class="board-section" data-category="club">
        <div class="section-title">동아리</div>
        <div class="section-content" id="club-content"></div>
      </div>
      <div class="board-section" data-category="afterschool">
        <div class="section-title">방과후</div>
        <div class="section-content" id="afterschool-content"></div>
      </div>
      <div class="board-section" data-category="etc">
        <div class="section-title">기타</div>
        <div class="section-content" id="etc-content"></div>
      </div>
      <div class="board-section" data-category="absence">
        <div class="section-title">결석(조퇴)</div>
        <div class="section-content" id="absence-content"></div>
      </div>
    </div>
  </div>

  <!-- Clock -->
  <div class="clock-container">
    <div class="analog-clock">
      <div class="clock-center"></div>
      <div class="hand hour-hand" id="hourHand"></div>
      <div class="hand minute-hand" id="minuteHand"></div>
      <div class="hand second-hand" id="secondHand"></div>
      <!-- Hour markers -->
      <div class="marker major" style="transform: translateX(-50%) rotate(0deg);"></div>
      <div class="marker" style="transform: translateX(-50%) rotate(30deg);"></div>
      <div class="marker" style="transform: translateX(-50%) rotate(60deg);"></div>
      <div class="marker major" style="transform: translateX(-50%) rotate(90deg);"></div>
      <div class="marker" style="transform: translateX(-50%) rotate(120deg);"></div>
      <div class="marker" style="transform: translateX(-50%) rotate(150deg);"></div>
      <div class="marker major" style="transform: translateX(-50%) rotate(180deg);"></div>
      <div class="marker" style="transform: translateX(-50%) rotate(210deg);"></div>
      <div class="marker" style="transform: translateX(-50%) rotate(240deg);"></div>
      <div class="marker major" style="transform: translateX(-50%) rotate(270deg);"></div>
      <div class="marker" style="transform: translateX(-50%) rotate(300deg);"></div>
      <div class="marker" style="transform: translateX(-50%) rotate(330deg);"></div>
    </div>

    <div class="digital-clock">
      <div class="time-display">
        <span id="hours">00</span>:<span id="minutes">00</span><span class="seconds" id="seconds">00</span>
      </div>
      <div class="date-display" id="date">MONDAY, JANUARY 1</div>
      <div class="tstat" id="tstat"></div>
    </div>
  </div>

  <!-- Attendance Info -->
  <div class="attendance-info">
    <div><span class="label">총원</span><span class="number" id="total-count">30명</span></div>
    <div><span class="label">결원</span><span class="number absent-count" id="absent-count">0명</span></div>
    <div><span class="label">현원</span><span class="number" id="present-count">30명</span></div>
  </div>

  <!-- Fullscreen Buttons -->
  <button class="fullscreen-btn" onclick="toggleFullscreen()">전체화면</button>
  <button class="exit-fullscreen-btn" onclick="exitFullscreen()">✕</button>

  <!-- 게임 버튼 -->
  <div class="fab-container" aria-live="polite">
    <button id="gameFab" class="fab" aria-haspopup="true" aria-expanded="false" aria-controls="gameMenu" title="게임 메뉴">
      <img src="src/game.png" alt="게임"/>
    </button>
    <div id="gameMenu" class="fab-menu" role="menu">
      <button class="fab-item" role="menuitem" id="fireworksItem">폭죽 터뜨리기</button>
      <button class="fab-item" role="menuitem" id="gomokuItem">오목 게임</button>
    </div>
  </div>

  <!-- Fireworks canvas container -->
  <div class="fireworks" aria-hidden="true"></div>

  <!-- 이유 입력 다이얼로그 -->
  <div id="reasonOverlay" class="dialog-overlay" hidden>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="reasonTitle">
      <div class="dialog-title" id="reasonTitle">어떤 이유인가요?</div>
      <textarea id="reasonInput" placeholder="예: 병원 예약, 상담, 급한 용무 등" rows="4" ></textarea>
      <div class="actions">
        <button id="reasonCancel" type="button">취소</button>
        <button id="reasonSave" class="primary" type="button">저장</button>
      </div>
    </div>
  </div>

  <div class="ultraman">
    <img src="Ultra_Jiwon.png" id="ultraman">
  </div>

  <!-- ===== Noise Meter + Toggle (묶음) ===== -->
  <div class="noise-wrap" id="noiseWrap">
    <div id="noiseMeter" class="noise-meter" aria-live="polite">
      dB: <span class="value" id="noiseValue">-∞</span>
      <span class="hint"> (임계 <span class="th" id="thVal">-10</span> dB)</span>
    </div>
    <button id="toggleNoiseBtn" class="toggle-noise-btn" type="button">측정 시작</button>
  </div>

  <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>

  <script>
    $(".ultraman").hide();
    /* ===================== 저장/복원 (localStorage) ===================== */
    const STORAGE_KEY = 'modernClock.magnets.v1';

    function saveState() {
      const magnets = {};
      document.querySelectorAll('.magnet:not(.placeholder)').forEach(m => {
        const num = m.dataset.number;
        const data = {};
        if (m.dataset.reason) data.reason = m.dataset.reason;
        if (m.classList.contains('attached')) {
          const section = m.closest('.board-section');
          data.attachedTo = section ? section.dataset.category : null;
        } else {
          data.attachedTo = null;
          data.left = parseFloat(m.style.left) || 0;
          data.top  = parseFloat(m.style.top)  || 0;
        }
        magnets[num] = data;
      });
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify({ v:1, magnets })); }
      catch (e) { console.warn('saveState failed:', e); }
    }

    function loadState() {
      let parsed;
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        parsed = JSON.parse(raw);
      } catch (e) {
        console.warn('loadState failed:', e);
        return;
      }
      if (!parsed || !parsed.magnets) return;

      Object.entries(parsed.magnets).forEach(([num, data]) => {
        const m = document.querySelector(`.magnet[data-number="${num}"]`);
        if (!m) return;

        // 이유 복원
        if (data.reason) {
          m.dataset.reason = data.reason;
          m.classList.add('has-reason');
        } else {
          delete m.dataset.reason;
          m.classList.remove('has-reason');
        }

        // 위치/소속 복원
        if (data.attachedTo) {
          const content = document.querySelector(`.board-section[data-category="${data.attachedTo}"] .section-content`);
          if (content) {
            m.classList.add('attached');
            m.style.left = '';
            m.style.top  = '';
            m.style.transform = '';
            content.appendChild(m);
          }
        } else {
          m.classList.remove('attached');
          const home = gridPos[+num] || { left: 0, top: 0 };
          m.style.left = ((data.left ?? home.left) + 0) + 'px';
          m.style.top  = ((data.top  ?? home.top)  + 0) + 'px';
          m.style.transform = 'translate(0,0)';
        }
      });

      sortAllSections();
      updateAttendance();
      updateMagnetOutline();
      updateEtcReasonPanel();
    }

    function resetSavedState() {
      localStorage.removeItem(STORAGE_KEY);
      location.reload();
    }
  </script>

  <script>
    /* ===================== 고정 격자 좌표/자리표 ===================== */
    const gridPos = {};                  // 번호 -> {left, top}
    const placeholders = new Map();      // 번호 -> 자리표 엘리먼트
    var isfired = 0;

    function createPlaceholder(num) {
      if (placeholders.has(num)) return;
      const pos = gridPos[num];
      if (!pos) return;
      const p = document.createElement('div');
      p.className = 'magnet placeholder';
      p.textContent = num;
      p.style.left = pos.left + 'px';
      p.style.top  = pos.top  + 'px';
      p.style.background = 'linear-gradient(135deg,#666,#444)';
      p.style.opacity = '0.5';
      p.style.cursor = 'default';
      p.style.pointerEvents = 'none';
      p.style.boxShadow = 'none';
      document.getElementById('magnetContainer').appendChild(p);
      placeholders.set(num, p);
    }

    /* ===================== 자석 생성 ===================== */
    function createMagnets() {
      const container = document.getElementById('magnetContainer');
      const rows = 6, cols = 5, size = 50, gap = 15;
      let n = 1;

      function getColorClass(num) {
        if (num >= 1 && num <= 5)   return 'color-red';
        if (num >= 6 && num <= 10)  return 'color-orange';
        if (num >= 11 && num <= 16) return 'color-yellow';
        if (num >= 17 && num <= 21) return 'color-green';
        if (num >= 22 && num <= 26) return 'color-blue';
        if (num >= 27 && num <= 31) return 'color-purple';
        return '';
      }

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (n > 31) break;
          if (n === 12) { n++; if (n > 31) break; } // 12번 건너뛰기

          const x = c * (size + gap) + 50;
          const y = r * (size + gap) + 500;
          gridPos[n] = { left: x, top: y };

          // 항상 회색 자리표 생성 (배경)
          createPlaceholder(n);

          const m = document.createElement('div');
          m.className = 'magnet';
          const colorClass = getColorClass(n);
          if (colorClass) m.classList.add(colorClass);

          m.textContent = n;
          m.dataset.number = n;
          m.style.left = x + 'px';
          m.style.top  = y + 'px';

          container.appendChild(m);
          addDragFunctionality(m);
          n++;
        }
      }

      const total = container.querySelectorAll('.magnet:not(.placeholder)').length;
      const tc = document.getElementById('total-count');
      if (tc) tc.textContent = `${total}명`;

      updateMagnetOutline();
    }

    /* ===================== 외곽선 ===================== */
    function ensureMagnetOutline() {
      const container = document.getElementById('magnetContainer');
      let outline = document.getElementById('magnetOutline');
      if (!outline) {
        outline = document.createElement('div');
        outline.id = 'magnetOutline';
        outline.className = 'magnet-outline';
        container.appendChild(outline);
      }
      return outline;
    }

    function updateMagnetOutline() {
      const container = document.getElementById('magnetContainer');
      const outline = ensureMagnetOutline();
      const nodes = container.querySelectorAll('.magnet:not(.attached)');

      if (!nodes.length) {
        outline.style.display = 'none';
        return;
      }

      let minL = Infinity, minT = Infinity, maxR = -Infinity, maxB = -Infinity;
      nodes.forEach(m => {
        const left = parseFloat(m.style.left) || 0;
        const top  = parseFloat(m.style.top)  || 0;
        const w = m.offsetWidth  || 50;
        const h = m.offsetHeight || 50;
        minL = Math.min(minL, left);
        minT = Math.min(minT, top);
        maxR = Math.max(maxR, left + w);
        maxB = Math.max(maxB, top  + h);
      });

      const pad = 8;
      outline.style.display = 'block';
      outline.style.left   = (minL - pad) + 'px';
      outline.style.top    = (minT - pad) + 'px';
      outline.style.width  = (maxR - minL + pad * 2) + 'px';
      outline.style.height = (maxB - minT + pad * 2) + 'px';
    }

    /* ===================== 출결 계산 ===================== */
    function updateAttendance() {
      const total = document.querySelectorAll('.magnet:not(.placeholder)').length;
      const excluded = new Set(['toilet', 'hallway']);

      let absentCount = 0;
      document.querySelectorAll('.board-section').forEach(section => {
        const cat = section.dataset.category;
        const content = section.querySelector('.section-content');
        if (!content) return;

        const n = content.querySelectorAll('.magnet:not(.placeholder)').length;
        if (!excluded.has(cat)) absentCount += n;
      });

      document.getElementById('total-count').textContent   = `${total}명`;
      document.getElementById('absent-count').textContent  = `${absentCount}명`;
      document.getElementById('present-count').textContent = `${total - absentCount}명`;
    }

    /* ===================== 섹션 정렬 & 기타 사유 패널 ===================== */
    function sortSection(contentEl) {
      const mags = Array.from(contentEl.querySelectorAll('.magnet'))
        .sort((a, b) => (+a.dataset.number) - (+b.dataset.number));
      mags.forEach(m => contentEl.appendChild(m));
    }
    function sortAllSections() {
      document.querySelectorAll('.section-content').forEach(sortSection);
    }

    // ✅ 같은 사유끼리 한 줄에: [사유] -> [번호들]로 그룹핑
    // ✅ 기타 사유 패널 렌더링 (배지 색을 자석과 동일하게 동기화)
    function updateEtcReasonPanel() {
      const list = document.getElementById('reasonList');
      if (!list) return;

      const etcContent = document.querySelector('[data-category="etc"] .section-content');
      const items = etcContent ? Array.from(etcContent.querySelectorAll('.magnet')) : [];

      // 그룹핑: reason -> [numbers]
      const groups = new Map();
      items.forEach(m => {
        const num = Number(m.dataset.number);
        const reason = (m.dataset.reason || '(이유 미입력)').trim();
        if (!groups.has(reason)) groups.set(reason, []);
        groups.get(reason).push(num);
      });

      // 정렬: 사유(한글 알파) -> 번호 오름차순
      const collator = new Intl.Collator('ko');
      const entries = Array.from(groups.entries()).sort((a, b) => collator.compare(a[0], b[0]));
      entries.forEach(([_, nums]) => nums.sort((a,b)=>a-b));

      // 렌더링
      list.innerHTML = '';
      if (!entries.length) {
        const empty = document.createElement('div');
        empty.textContent = '현재 등록된 기타 사유가 없습니다.';
        empty.style.opacity = '0.7';
        list.appendChild(empty);
        return;
      }

      entries.forEach(([reason, nums]) => {
        const row = document.createElement('div');
        row.className = 'reason-item';

        const badges = document.createElement('div');
        badges.className = 'badges';

        nums.forEach(n => {
          const b = document.createElement('span');
          b.className = 'badge';
          b.textContent = n;

          // 🔗 자석 DOM 찾아서 스타일/클래스 동기화
          const mag = document.querySelector(`.magnet[data-number="${n}"]`);
          if (mag) {
            // 1) color-* 클래스 복사
            mag.classList.forEach(cls => {
              if (cls.startsWith('color-')) b.classList.add(cls);
            });

            // 2) 실제 렌더된 스타일 복사
            const cs = getComputedStyle(mag);
            const bgImg = cs.backgroundImage;
            const bgCol = cs.backgroundColor;
            const fgCol = cs.color;

            if (bgImg && bgImg !== 'none') {
              b.style.backgroundImage = bgImg;
              b.style.backgroundColor = 'transparent';
            } else {
              b.style.backgroundImage = 'none';
              b.style.backgroundColor = bgCol;
            }
            b.style.color = fgCol;
          }

          badges.appendChild(b);
        });

        const text = document.createElement('div');
        text.className = 'reason-text';
        text.textContent = reason;

        row.appendChild(badges);
        row.appendChild(text);
        list.appendChild(row);
      });
    }

    /* ===================== 유틸: 원래 자리로 스냅 ===================== */
    function snapToHome(el) {
      const pos = gridPos[+el.dataset.number];
      if (!pos) return;
      el.style.left = pos.left + 'px';
      el.style.top  = pos.top  + 'px';
      el.style.transform = 'translate(0,0)';
    }

    /* ===================== 드래그 ===================== */
    function addDragFunctionality(el) {
      let isDragging = false;
      let currentX, currentY, initialX, initialY, xOffset = 0, yOffset = 0;

      function dragStart(e) {
        if (el.classList.contains('attached')) {
          const rect = el.getBoundingClientRect();
          const container = document.getElementById('magnetContainer');
          const containerRect = container.getBoundingClientRect();

          el.classList.remove('attached');
          container.appendChild(el);

          el.style.left = (rect.left - containerRect.left) + 'px';
          el.style.top  = (rect.top  - containerRect.top)  + 'px';
          el.style.transform = 'translate(0,0)';

          updateAttendance();
          updateMagnetOutline();
          updateEtcReasonPanel();
          saveState();
        }

        if (e.type === "touchstart") {
          initialX = e.touches[0].clientX - xOffset;
          initialY = e.touches[0].clientY - yOffset;
        } else {
          initialX = e.clientX - xOffset;
          initialY = e.clientY - yOffset;
        }

        if (e.target === el) {
          isDragging = true;
          el.classList.add('dragging');
        }
      }

      function drag(e) {
        if (!isDragging) return;
        e.preventDefault();

        if (e.type === "touchmove") {
          currentX = e.touches[0].clientX - initialX;
          currentY = e.touches[0].clientY - initialY;
        } else {
          currentX = e.clientX - initialX;
          currentY = e.clientY - initialY;
        }

        xOffset = currentX;
        yOffset = currentY;

        if (!el.classList.contains('attached')) {
          const container = document.getElementById('magnetContainer');
          const containerRect = container.getBoundingClientRect();

          const curL = parseFloat(el.style.left) || 0;
          const curT = parseFloat(el.style.top)  || 0;

          let newX = curL + currentX;
          let newY = curT + currentY;

          if (newX < 0) newX = 0;
          if (newY < 0) newY = 0;
          if (newX > containerRect.width  - el.offsetWidth)  newX = containerRect.width  - el.offsetWidth;
          if (newY > containerRect.height - el.offsetHeight) newY = containerRect.height - el.offsetHeight;

          el.style.left = newX + 'px';
          el.style.top  = newY + 'px';
          el.style.transform = 'translate(0,0)';

          if (e.type === "touchmove") {
            initialX = e.touches[0].clientX;
            initialY = e.touches[0].clientY;
          } else {
            initialX = e.clientX;
            initialY = e.clientY;
          }
          xOffset = 0; yOffset = 0;

          updateMagnetOutline();
        } else {
          el.style.transform = `translate(${currentX}px, ${currentY}px)`;
        }

        // 드롭존 하이라이트
        const r = el.getBoundingClientRect();
        const cx = r.left + r.width / 2;
        const cy = r.top  + r.height / 2;
        document.querySelectorAll('.board-section').forEach(sec => {
          const sr = sec.getBoundingClientRect();
          if (cx >= sr.left && cx <= sr.right && cy >= sr.top && cy <= sr.bottom) {
            sec.classList.add('drag-over');
          } else {
            sec.classList.remove('drag-over');
          }
        });
      }

      function dragEnd() {
        if (!isDragging) return;
        isDragging = false;
        el.classList.remove('dragging');

        const r = el.getBoundingClientRect();
        const cx = r.left + r.width / 2;
        const cy = r.top  + r.height / 2;

        let targetSection = null;
        document.querySelectorAll('.board-section').forEach(sec => {
          const sr = sec.getBoundingClientRect();
          if (cx >= sr.left && cx <= sr.right && cy >= sr.top && cy <= sr.bottom) {
            targetSection = sec;
          }
        });

        if (targetSection) {
          const content = targetSection.querySelector('.section-content');
          el.classList.add('attached');
          el.style.transform = '';
          el.style.left = '';
          el.style.top  = '';
          content.appendChild(el);

          // 번호순 정렬
          sortSection(content);

          // 기타면 이유 입력(없으면 물어봄), 아니면 이유 제거
          if (targetSection.dataset.category === 'etc') {
            if (!el.dataset.reason) openReasonDialog(el);
          } else {
            if (el.dataset.reason) {
              delete el.dataset.reason;
              el.classList.remove('has-reason');
            }
          }
        } else {
          // 섹션이 아니면 항상 원래 자리로 복귀 + 이유 제거
          snapToHome(el);
          if (el.dataset.reason) {
            delete el.dataset.reason;
            el.classList.remove('has-reason');
          }
        }

        updateAttendance();
        updateMagnetOutline();
        updateEtcReasonPanel();
        saveState();

        document.querySelectorAll('.board-section').forEach(sec => sec.classList.remove('drag-over'));
      }

      el.addEventListener('mousedown', dragStart);
      document.addEventListener('mousemove', drag);
      document.addEventListener('mouseup', dragEnd);

      el.addEventListener('touchstart', dragStart, { passive: false });
      document.addEventListener('touchmove', drag, { passive: false });
      document.addEventListener('touchend', dragEnd);
    }

    /* ===================== 이유 모달 ===================== */
    let currentReasonTarget = null;

    function openReasonDialog(target) {
      currentReasonTarget = target;
      const overlay = document.getElementById('reasonOverlay');
      const input = document.getElementById('reasonInput');
      input.value = target.dataset.reason || "";
      overlay.hidden = false;
      setTimeout(() => input.focus(), 0);
    }

    function closeReasonDialog() {
      document.getElementById('reasonOverlay').hidden = true;
      currentReasonTarget = null;
    }

    document.getElementById('reasonSave').addEventListener('click', () => {
      const input = document.getElementById('reasonInput');
      const text = input.value.trim();
      if (currentReasonTarget) {
        if (text) {
          currentReasonTarget.dataset.reason = text;
          currentReasonTarget.classList.add('has-reason');
        } else {
          delete currentReasonTarget.dataset.reason;
          currentReasonTarget.classList.remove('has-reason');
        }
      }
      closeReasonDialog();
      sortAllSections();
      updateEtcReasonPanel();
      saveState();
    });

    document.getElementById('reasonCancel').addEventListener('click', () => {
      closeReasonDialog();
      updateEtcReasonPanel();
    });

    document.getElementById('reasonOverlay').addEventListener('mousedown', (e) => {
      if (e.target.id === 'reasonOverlay') {
        closeReasonDialog();
        updateEtcReasonPanel();
      }
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && !document.getElementById('reasonOverlay').hidden) {
        closeReasonDialog();
        updateEtcReasonPanel();
      }
    });

    /* ===================== 전체화면/시계 ===================== */
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().then(() => {
          document.body.classList.add('fullscreen');
        }).catch(()=>{});
      }
    }
    function exitFullscreen() {
      if (document.fullscreenElement) {
        document.exitFullscreen().then(() => {
          document.body.classList.remove('fullscreen');
        }).catch(()=>{});
      }
    }
    document.addEventListener('fullscreenchange', () => {
      if (!document.fullscreenElement) document.body.classList.remove('fullscreen');
    });

    function updateClock() {
      const now = new Date();
      const h = String(now.getHours()).padStart(2, '0');
      const m = String(now.getMinutes()).padStart(2, '0');
      const s = String(now.getSeconds()).padStart(2, '0');
      document.getElementById('hours').textContent = h;
      document.getElementById('minutes').textContent = m;
      document.getElementById('seconds').textContent = s;

      const days = ['일요일','월요일','화요일','수요일','목요일','금요일','토요일'];
      const months = ['1월','2월','3월','4월','5월','6월','7월','8월','9월','10월','11월','12월'];
      document.getElementById('date').textContent =
        `${months[now.getMonth()]} ${now.getDate()}일 ${days[now.getDay()]}`;

      const tstatEl = document.getElementById('tstat');
      const hh = Number(h), mm = Number(m), ss = Number(s);
      if (hh < 8 || (hh === 8 && mm < 10)) {
        tstatEl.textContent = '아침 시간';
      } else if (hh === 8 && mm >= 10 && mm < 50) {
        tstatEl.textContent = '아침 자습';
      } else if (hh === 8 && mm >= 50) {
        tstatEl.textContent = '아침 조회';
      } else if (hh === 17 && (mm >= 10 && mm < 50)) {
        tstatEl.textContent = '방과후 1타임';
      } else if (hh === 17 && (mm >= 50 && mm < 55)) {
        tstatEl.textContent = '쉬는 시간';
      } else if ((hh === 17 && mm >= 55) || (hh === 18 && mm < 35)) {
        tstatEl.textContent = '방과후 2타임';
      } else if ((hh === 18 && mm >= 35) || (hh === 19 && mm < 50)) {
        tstatEl.textContent = '저녁 시간';
      } else if ((hh === 19 && mm >= 50) || hh === 20 || (hh === 21 && mm < 10)) {
        tstatEl.textContent = '야자 1타임';
      } else if ((hh === 21 && mm >= 10 && mm < 30)) {
        tstatEl.textContent = '쉬는 시간';
      } else if ((hh === 21 && mm >= 30) || (hh === 22 && mm < 50)) {
        tstatEl.textContent = '야자 2타임';
      } else if (hh === 22 && mm === 49) {
        if (ss >= 50) {
          tstatEl.textContent = String(60 - ss);
        } else {
          tstatEl.textContent = '야자 2타임';
        }
      } else if (hh === 22 && mm >= 50) {
        tstatEl.textContent = '끝.';
        if (isfired == 0) {
          isfired = 1;
          const container = document.querySelector('.fireworks');
          const fireworks = new Fireworks.default(container);
          fireworks.start();
        }
      } else {
        tstatEl.textContent = '';
      }

      const hoursDeg = (now.getHours() % 12) * 30 + (now.getMinutes() * 0.5);
      const minutesDeg = now.getMinutes() * 6 + (now.getSeconds() * 0.1);
      const secondsDeg = now.getSeconds() * 6;
      document.getElementById('hourHand').style.transform   = `translateX(-50%) rotate(${hoursDeg}deg)`;
      document.getElementById('minuteHand').style.transform = `translateX(-50%) rotate(${minutesDeg}deg)`;
      document.getElementById('secondHand').style.transform = `translateX(-50%) rotate(${secondsDeg}deg)`;
    }

    // 초기화
    createMagnets();
    loadState();

    updateAttendance();
    updateEtcReasonPanel();
    updateClock();
    setInterval(updateClock, 1000);
    setTimeout(() => {
      const sh = document.getElementById('secondHand');
      if (sh) sh.style.transition = 'transform 0.5s cubic-bezier(0.4, 0.0, 0.2, 1)';
    }, 1000);
  </script>

  <script>
    // 게임 FAB 토글 및 메뉴 동작
    (function () {
      const fab = document.getElementById('gameFab');
      const menu = document.getElementById('gameMenu');
      const gomoku = document.getElementById('gomokuItem');
      const fireworksBtn = document.getElementById('fireworksItem');
      let menuFireworks = null;
      let fwStopTimer = null;

      if (!fab || !menu) return;

      function closeMenu() {
        menu.classList.remove('open');
        fab.setAttribute('aria-expanded', 'false');
      }

      function toggleMenu(e) {
        e.stopPropagation();
        const isOpen = menu.classList.toggle('open');
        fab.setAttribute('aria-expanded', String(isOpen));
      }

      fab.addEventListener('click', toggleMenu);
      document.addEventListener('click', (e) => {
        if (!menu.classList.contains('open')) return;
        const t = e.target;
        if (t === fab || fab.contains(t) || menu.contains(t)) return;
        closeMenu();
      });
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') closeMenu();
      });

      if (gomoku) {
        gomoku.addEventListener('click', () => {
          window.location.href = 'gomoku.html';
        });
      }

      if (fireworksBtn) {
        fireworksBtn.addEventListener('click', () => {
          const container = document.querySelector('.fireworks');
          if (!container || !window.Fireworks) return;
          if (!menuFireworks) menuFireworks = new Fireworks.default(container);
          menuFireworks.start();
          if (fwStopTimer) clearTimeout(fwStopTimer);
          fwStopTimer = setTimeout(() => {
            try {
              if (menuFireworks && typeof menuFireworks.stop === 'function') menuFireworks.stop(true);
            } catch (_) {}
          }, 3500);
          closeMenu();
        });
      }
    })();

    $(".analog-clock")
    .on("mousedown touchstart", function () {
      $(".ultraman").show();
    })
    .on("mouseup mouseleave touchend touchcancel", function () {
      $(".ultraman").hide();
    });

  </script>

  <!-- ===== 소음 측정 + 임계치 경고음 (버튼으로 On/Off) ===== -->
  <script>
    // 임계치(dB). 환경/마이크에 따라 보정 권장
    let THRESHOLD_DB = -10;
    const BEEP_COOLDOWN = 1500;

    const noiseEl = document.getElementById('noiseMeter');
    const noiseValEl = document.getElementById('noiseValue');
    const thValEl = document.getElementById('thVal');
    const toggleBtn = document.getElementById('toggleNoiseBtn');

    thValEl.textContent = THRESHOLD_DB;

    let audioCtx = null;
    let analyser = null;
    let dataArray = null;
    let micSource = null;
    let micStream = null;
    let rafId = null;
    let lastBeepAt = 0;
    let measuring = false;

    function playBeep() {
      const ctx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
      if (!audioCtx) audioCtx = ctx;
      const now = ctx.currentTime;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = "sine";
      osc.frequency.value = 1000;
      gain.gain.value = 0.15;
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start(now);
      osc.stop(now + 0.25);
    }

    function dbFromRMS(rms) {
      if (rms <= 0) return -Infinity;
      return 20 * Math.log10(rms);
    }

    function loop() {
      if (!analyser || !dataArray || !measuring) return;
      analyser.getByteTimeDomainData(dataArray);
      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) {
        const v = (dataArray[i] - 128) / 128;
        sum += v * v;
      }
      const rms = Math.sqrt(sum / dataArray.length);
      const db  = dbFromRMS(rms);

      noiseValEl.textContent = isFinite(db) ? db.toFixed(1) : '-∞';

      const nowMs = performance.now();
      if (db > THRESHOLD_DB) {
        noiseEl.classList.add('alert');
        if (nowMs - lastBeepAt > BEEP_COOLDOWN) {
          lastBeepAt = nowMs;
          playBeep();
        }
      } else {
        noiseEl.classList.remove('alert');
      }

      rafId = requestAnimationFrame(loop);
    }

    async function startNoiseMeter() {
      if (measuring) return;
      try {
        micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        micSource = audioCtx.createMediaStreamSource(micStream);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        dataArray = new Uint8Array(analyser.fftSize);
        micSource.connect(analyser);
        measuring = true;
        toggleBtn.textContent = '측정 중지';
        loop();
      } catch (e) {
        console.error(e);
        alert('마이크 권한이 필요합니다.');
      }
    }

    function stopNoiseMeter() {
      measuring = false;
      if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
      if (micStream) {
        try { micStream.getTracks().forEach(t => t.stop()); } catch (_) {}
        micStream = null;
      }
      if (audioCtx) {
        try { audioCtx.close(); } catch (_) {}
        audioCtx = null;
      }
      analyser = null;
      dataArray = null;
      micSource = null;
      noiseValEl.textContent = '-∞';
      noiseEl.classList.remove('alert');
      toggleBtn.textContent = '측정 시작';
    }

    toggleBtn.addEventListener('click', () => {
      if (!measuring) startNoiseMeter();
      else stopNoiseMeter();
    });

    // 노이즈 패널 클릭시 임계치 토글(예시)
    noiseEl.addEventListener('click', () => {
      THRESHOLD_DB = (THRESHOLD_DB === -10) ? -15 : -10;
      thValEl.textContent = THRESHOLD_DB;
    });
  </script>
</body>
</html>
